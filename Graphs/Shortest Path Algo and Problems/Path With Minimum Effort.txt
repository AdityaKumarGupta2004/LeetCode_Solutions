class Solution {
    public int minimumEffortPath(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;

        // directions: up, left, right, down
        int[][] dirs = {{-1,0},{0,-1},{0,1},{1,0}};

        // effort[r][c] = min possible maximum edge-diff to reach (r,c)
        int[][] effort = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                effort[i][j] = (int)1e9;
            }
        }
        effort[0][0] = 0;

        // min-heap: {effortSoFar, row, col}
        PriorityQueue<int[]> pq = new PriorityQueue<>(
            (a, b) -> Integer.compare(a[0], b[0])
        );
        pq.offer(new int[]{0, 0, 0});

        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int dist = curr[0];
            int r = curr[1];
            int c = curr[2];

            // if this is a stale entry, skip
            if (dist > effort[r][c]) continue;

            // reached destination
            if (r == n - 1 && c == m - 1) {
                return dist;
            }

            for (int[] d : dirs) {
                int nr = r + d[0];
                int nc = c + d[1];

                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int edge = Math.abs(grid[nr][nc] - grid[r][c]);
                    int newEffort = Math.max(dist, edge);

                    if (newEffort < effort[nr][nc]) {
                        effort[nr][nc] = newEffort;
                        pq.offer(new int[]{newEffort, nr, nc});
                    }
                }
            }
        }

        return 0; // for completeness, won't be hit for valid input
    }
}

// like the dp to store the maximum effort to visit the cell 

Define a queue to store pairs of {difference, (row, col)} where 'difference' represents the current difference from the source node to the current cell.
Initialize a distance matrix with all cells set to a large number (âˆž), except for the source node, which is set to 0.
Push the source node into the queue with its initial difference (0).
While the queue is not empty, pop the front element. This gives the current node and its associated difference.
For each adjacent node (left, right, top, and bottom), check if the node lies within valid matrix bounds.
For each valid adjacent node, calculate the new difference by adding the edge weight to the current difference of the node.
If the newly calculated difference is smaller than the value in the distance matrix, update the matrix with the new difference.
Push the adjacent node with the updated difference back into the queue for further processing.
The queue operates like a min-heap, so nodes with smaller differences are processed first.
Repeat the process until the queue is empty or the destination node is reached.
If the destination node is found, return the calculated difference as the shortest path from the source to the destination.
If the queue becomes empty and the destination node hasn't been reached, return 0, indicating no path exists from source to destination.