class Solution {
    public int minimumEffortPath(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;

        // directions: up, left, right, down
        int[][] dirs = {{-1,0},{0,-1},{0,1},{1,0}};

        // effort[r][c] = min possible maximum edge-diff to reach (r,c)
        int[][] effort = new int[n][m];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                effort[i][j] = (int)1e9;
            }
        }
        effort[0][0] = 0;

        // min-heap: {effortSoFar, row, col}
        PriorityQueue<int[]> pq = new PriorityQueue<>(
            (a, b) -> Integer.compare(a[0], b[0])
        );
        pq.offer(new int[]{0, 0, 0});

        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int dist = curr[0];
            int r = curr[1];
            int c = curr[2];

            // if this is a stale entry, skip
            if (dist > effort[r][c]) continue;

            // reached destination
            if (r == n - 1 && c == m - 1) {
                return dist;
            }

            for (int[] d : dirs) {
                int nr = r + d[0];
                int nc = c + d[1];

                if (nr >= 0 && nr < n && nc >= 0 && nc < m) {
                    int edge = Math.abs(grid[nr][nc] - grid[r][c]);
                    int newEffort = Math.max(dist, edge);

                    if (newEffort < effort[nr][nc]) {
                        effort[nr][nc] = newEffort;
                        pq.offer(new int[]{newEffort, nr, nc});
                    }
                }
            }
        }

        return 0; // for completeness, won't be hit for valid input
    }
}

// like the dp to store the maximum effort to visit the cell 